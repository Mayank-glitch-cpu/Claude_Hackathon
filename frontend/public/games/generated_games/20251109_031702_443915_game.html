<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Boilpoint: Night Market Ramen Lab</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@600;700&family=Nunito:wght@400;600;700&family=Roboto+Mono:wght@500&display=swap" rel="stylesheet">
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root{
        --primary:#0EA5E9;
        --secondary:#22D3EE;
        --accent:#F59E0B;
        --success:#10B981;
        --danger:#EF4444;
        --bg:#0F172A;
        --surface: rgba(15, 23, 42, 0.6);
        --text:#E5E7EB;
        --muted:#94A3B8;
        --shadow: 0 20px 60px rgba(0,0,0,0.35);
        --panel-shadow: 0 10px 30px rgba(0,0,0,0.25);
        --ring-green: #16a34a;
        --ring-yellow: #f59e0b;
        --ring-red: #ef4444;
        --ring-blue: #60a5fa;
    }
    html, body { height: 100%; }
    body {
        font-family: 'Nunito', system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, 'Helvetica Neue', Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
        color: var(--text);
        background: linear-gradient(135deg, #0EA5E9 0%, #22D3EE 40%, #0F172A 100%);
        min-height: 100vh;
        padding: 20px 20px 90px;
        overflow-x: hidden;
    }
    h1,h2,h3,h4 { font-family: 'Inter', sans-serif; }
    .mono { font-family: 'Roboto Mono', monospace; }

    #app {
        max-width: 1200px;
        margin: 0 auto;
        border-radius: 20px;
        padding: 20px;
        box-shadow: var(--shadow);
        position: relative;
        backdrop-filter: blur(12px);
        border: 1px solid rgba(255,255,255,0.08);
        background: linear-gradient(180deg, rgba(15, 23, 42, 0.60), rgba(15, 23, 42, 0.45));
    }

    .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 12px;
    }
    .title {
        font-size: 1.8rem;
        color: #E0F2FE;
        display: flex; gap: 10px; align-items: center;
    }
    .title .badge {
        font-size: 0.85rem;
        color: #0F172A;
        background: linear-gradient(135deg, #22D3EE, #0EA5E9);
        padding: 6px 10px;
        border-radius: 12px;
        font-weight: 700;
        box-shadow: 0 6px 16px rgba(14,165,233,0.35);
    }
    .subtitle {
        color: #B3E5FC;
        margin-bottom: 16px;
        opacity: 0.9;
    }

    .grid {
        display: grid;
        grid-template-columns: 1.1fr 1.8fr 1.1fr;
        gap: 16px;
    }

    .panel {
        background: var(--surface);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 16px;
        padding: 16px;
        box-shadow: var(--panel-shadow);
        transition: transform 0.25s ease, box-shadow 0.25s ease, border-color 0.25s ease;
        position: relative;
    }
    .panel:hover { transform: translateY(-2px); box-shadow: 0 14px 36px rgba(0,0,0,0.35); }

    #hud .statbar {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
        margin-bottom: 12px;
    }
    .pill {
        background: rgba(255,255,255,0.06);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 12px;
        padding: 8px 10px;
        display: flex; align-items: center; justify-content: space-between;
    }
    .pill .label { color: var(--muted); font-size: 0.8rem; }
    .pill .value { color: #E5E7EB; font-weight: 700; }

    #orderCard {
        margin-top: 8px;
        animation: cardSlideIn 600ms ease both;
    }
    #orderCard h3 {
        font-size: 1.1rem;
        margin-bottom: 8px;
        color: #E0F2FE;
    }
    .order-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px; }
    .order-item {
        background: rgba(255,255,255,0.06);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 12px; padding: 8px;
    }
    .order-item strong { color: #CFFAFE; display:block; font-size: 0.85rem; }
    .order-item span { font-size: 0.95rem; }

    #stage {
        display: grid;
        grid-template-rows: auto 1fr;
        gap: 10px;
        min-height: 420px;
        position: relative;
        overflow: hidden;
    }

    #potArea {
        position: relative;
        background: radial-gradient(1200px 600px at 50% -400px, rgba(255,255,255,0.06), rgba(255,255,255,0.02) 40%, rgba(0,0,0,0) 70%), rgba(255,255,255,0.03);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 18px;
        min-height: 360px;
        overflow: hidden;
        user-select: none;
    }
    #heatRing {
        position: absolute;
        inset: 10px;
        border-radius: 50%;
        pointer-events: none;
        box-shadow: inset 0 0 0 10px rgba(255,255,255,0.03), 0 0 30px rgba(0,0,0,0.3);
        transition: box-shadow 200ms ease, filter 200ms ease;
    }
    .ring-green { box-shadow: inset 0 0 0 8px rgba(16,185,129,0.55), 0 0 40px rgba(16,185,129,0.25); }
    .ring-yellow { box-shadow: inset 0 0 0 8px rgba(245,158,11,0.55), 0 0 40px rgba(245,158,11,0.25); }
    .ring-red { box-shadow: inset 0 0 0 8px rgba(239,68,68,0.55), 0 0 40px rgba(239,68,68,0.25); }
    .ring-blue { box-shadow: inset 0 0 0 8px rgba(96,165,250,0.55), 0 0 40px rgba(96,165,250,0.25); }

    #stageCanvas {
        width: 100%;
        height: 100%;
        display: block;
        filter: drop-shadow(0 4px 20px rgba(0,0,0,0.4));
    }

    .stage-overlay {
        position: absolute; left: 10px; top: 10px; right: 10px; display:flex; gap:8px; justify-content: space-between; pointer-events: none;
    }
    .overlay-pill {
        background: rgba(2,6,23,0.55);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 10px;
        padding: 6px 10px;
        font-size: 0.9rem;
    }

    #controls .group { margin-bottom: 14px; }
    .control-card {
        background: rgba(255,255,255,0.06);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 12px;
        padding: 12px;
        transition: all 0.3s ease;
    }
    .control-card:hover { transform: translateY(-2px); box-shadow: 0 8px 22px rgba(0,0,0,0.25); }

    #heatKnob {
        margin: 8px auto 6px;
        width: 120px; height: 120px;
        background: radial-gradient(circle at 30% 30%, #ffffff33, #00000022), linear-gradient(135deg, #1e293b, #0f172a);
        border-radius: 50%;
        border: 2px solid rgba(255,255,255,0.1);
        box-shadow: inset 0 12px 22px rgba(255,255,255,0.04), inset 0 -12px 22px rgba(0,0,0,0.3), 0 12px 30px rgba(0,0,0,0.35);
        position: relative;
        cursor: grab;
        transition: transform 0.2s ease;
        touch-action: none;
    }
    #heatKnob:active { cursor: grabbing; }
    #heatKnob::after {
        content:'';
        position: absolute;
        width: 6px; height: 24px; background: #22D3EE;
        border-radius: 3px;
        top: 8px; left: calc(50% - 3px);
        box-shadow: 0 0 12px rgba(34,211,238,0.9);
    }
    .knob-label { text-align: center; font-weight: 700; color:#CFFAFE; }

    #waterPitcher {
        display: flex; align-items: center; gap: 10px;
    }
    #waterPitcher .icon {
        width: 44px; height: 60px; border-radius: 10px 10px 6px 6px;
        background: linear-gradient(180deg, #e0f2feaa, #67e8f9dd);
        border: 2px solid rgba(255,255,255,0.6);
        box-shadow: inset 0 10px 18px rgba(255,255,255,0.5), 0 8px 20px rgba(0,0,0,0.3);
        position: relative;
    }
    #waterPitcher .icon:before {
        content:'';
        position:absolute; right:-10px; top:10px; width: 18px; height: 14px; border-radius: 0 10px 10px 0;
        background: linear-gradient(180deg, #e0f2feaa, #67e8f9dd);
        border: 2px solid rgba(255,255,255,0.6);
        border-left: none;
    }
    #pourControl {
        -webkit-appearance: none; appearance:none;
        flex: 1;
        height: 10px; border-radius: 8px;
        background: linear-gradient(90deg, #0EA5E9, #22D3EE);
        outline: none; border: 1px solid rgba(255,255,255,0.2);
        box-shadow: inset 0 2px 8px rgba(0,0,0,0.4);
    }
    #pourControl::-webkit-slider-thumb {
        -webkit-appearance: none; appearance:none;
        width: 22px; height: 22px; border-radius: 50%;
        background: linear-gradient(135deg, #22D3EE, #0EA5E9);
        border: 2px solid #e0f2fe;
        box-shadow: 0 0 12px rgba(34,211,238,0.8);
        cursor: pointer;
        transition: transform 0.2s ease;
    }
    #pourControl:active::-webkit-slider-thumb { transform: scale(1.08); }

    #seasonPacket {
        height: 60px; border-radius: 10px; min-width: 100px;
        background: linear-gradient(135deg, #F59E0B, #FDE68A);
        border: 2px solid rgba(255,255,255,0.6);
        box-shadow: 0 10px 20px rgba(0,0,0,0.25);
        display:flex; align-items:center; justify-content:center;
        color:#1f2937; font-weight: 800;
        user-select: none;
        transition: transform 0.25s ease, box-shadow 0.25s ease;
    }
    #seasonPacket:hover { transform: translateY(-2px); box-shadow: 0 14px 28px rgba(0,0,0,0.35); }
    #seasonPacket[draggable="true"] { cursor: grab; }
    #seasonPacket:active { cursor: grabbing; }

    #strainerBtn, .btn {
        width: 100%;
        background: linear-gradient(135deg, #22D3EE, #0EA5E9);
        color: #0F172A;
        border: none;
        padding: 10px 14px;
        font-weight: 800;
        border-radius: 12px;
        box-shadow: 0 10px 24px rgba(14,165,233,0.35);
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.25s ease, filter 0.2s ease;
    }
    #strainerBtn:hover, .btn:hover { transform: translateY(-2px); box-shadow: 0 14px 30px rgba(14,165,233,0.45); }
    #strainerBtn:active, .btn:active { transform: translateY(0); filter: brightness(0.95); }
    #strainerBtn[disabled] { opacity: 0.5; cursor: not-allowed; }

    #ingredients {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
    }
    .ingredient {
        background: rgba(255,255,255,0.06);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 12px; padding: 10px;
        display:flex; align-items:center; gap:10px;
        cursor: grab;
        user-select: none;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .ingredient:hover { transform: translateY(-2px); box-shadow: 0 10px 22px rgba(0,0,0,0.25); }
    .ingredient:active { cursor: grabbing; }
    .ingredient .icon {
        width: 28px; height: 28px; border-radius: 50%;
        box-shadow: inset 0 4px 10px rgba(0,0,0,0.35), 0 4px 10px rgba(0,0,0,0.25);
    }
    .ingredient .name { font-weight: 700; color: #E0F2FE; }

    .legend {
        margin-top: 10px;
        font-size: 0.85rem;
        color: var(--muted);
    }

    #timeline {
        position: fixed;
        left: 0; right: 0; bottom: 0;
        padding: 10px 16px 16px;
        pointer-events: none;
    }
    .timeline-inner {
        max-width: 1200px; margin: 0 auto;
        background: rgba(2,6,23,0.6);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 14px;
        padding: 12px;
        backdrop-filter: blur(10px);
        box-shadow: var(--panel-shadow);
        pointer-events: all;
    }
    .timeline-row {
        display:flex; align-items:center; gap:12px;
    }
    #progress {
        position: relative;
        flex: 1;
        background: rgba(255,255,255,0.08);
        border: 1px solid rgba(255,255,255,0.08);
        height: 12px; border-radius: 999px; overflow: hidden;
    }
    #progressBar {
        position: absolute; left: 0; top: 0; bottom: 0; width: 0%;
        background: linear-gradient(90deg, #0EA5E9, #22D3EE);
        box-shadow: 0 0 18px rgba(34,211,238,0.6);
        transition: width 0.2s linear;
    }
    .tick {
        position: absolute; top: 0; bottom: 0; width: 2px;
        background: rgba(255,255,255,0.15);
        animation: tickFlash 900ms ease;
    }
    .timeline-time {
        min-width: 140px; text-align: right; font-family: 'Roboto Mono', monospace; color:#E0F2FE; font-weight:700;
    }
    .timeline-controls { display:flex; gap: 8px; }
    .sm-btn {
        background: linear-gradient(135deg, #1f2937, #0f172a);
        border: 1px solid rgba(255,255,255,0.1);
        color: #CFFAFE;
        padding: 8px 12px; border-radius: 10px; cursor: pointer; font-weight: 700;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .sm-btn:hover { transform: translateY(-2px); box-shadow: 0 10px 22px rgba(0,0,0,0.25); }

    #scoreModal {
        position: fixed;
        inset: 0;
        backdrop-filter: blur(10px);
        background: rgba(2,6,23,0.55);
        display: none;
        align-items: center;
        justify-content: center;
        padding: 16px;
        z-index: 50;
    }
    .modal-content {
        background: rgba(15,23,42,0.85);
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 16px;
        max-width: 900px;
        width: 100%;
        box-shadow: var(--shadow);
        overflow: hidden;
        animation: cardSlideIn 500ms ease;
    }
    .modal-header {
        display:flex; align-items:center; justify-content:space-between;
        padding: 14px 18px;
        border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .modal-body {
        padding: 16px;
        display: grid;
        grid-template-columns: 1.2fr 1fr;
        gap: 14px;
    }
    .score-bars .bar { margin-bottom: 10px; }
    .score-bars .bar .label { font-size: 0.9rem; color:#CFFAFE; margin-bottom: 4px; }
    .score-bars .track {
        height: 12px; border-radius: 999px; background: rgba(255,255,255,0.08); overflow: hidden; border:1px solid rgba(255,255,255,0.1);
    }
    .score-bars .fill {
        height: 100%; width: 0%;
        background: linear-gradient(90deg, #10B981, #22D3EE);
        box-shadow: 0 0 18px rgba(16,185,129,0.5);
        transition: width 800ms ease;
    }
    .replay {
        background: rgba(255,255,255,0.06);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 12px;
        padding: 12px;
        height: 220px; overflow:auto;
    }
    .replay-item { font-size: 0.9rem; color:#E5E7EB; margin-bottom:6px; }
    .challenge {
        background: rgba(255,255,255,0.06);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 12px; padding: 12px;
    }
    .challenge input, .challenge textarea {
        width: 100%; margin-top: 8px; padding: 10px;
        border-radius: 10px;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(0,0,0,0.25);
        color: #E5E7EB;
        outline: none;
    }

    #toasts {
        position: fixed; right: 18px; top: 18px; display:flex; flex-direction: column; gap: 10px; z-index: 40;
    }
    .toast {
        background: rgba(2,6,23,0.75);
        border: 1px solid rgba(255,255,255,0.08);
        color: #E5E7EB;
        padding: 10px 12px;
        border-radius: 10px;
        box-shadow: var(--panel-shadow);
        animation: cardSlideIn 350ms ease;
        font-size: 0.95rem;
    }

    .hint { color: #93C5FD; font-size: 0.85rem; margin-top: 6px; }

    .badge-list { display:flex; gap: 6px; flex-wrap: wrap; margin-top: 6px; }
    .badge-item {
        background: rgba(255,255,255,0.06); padding: 4px 8px; border-radius: 999px; font-size: 0.75rem;
        border: 1px solid rgba(255,255,255,0.08);
    }

    .hoverLift { transition: transform 0.25s ease, box-shadow 0.25s ease; }
    .hoverLift:hover { transform: translateY(-3px); box-shadow: 0 16px 32px rgba(0,0,0,0.35); }

    .hidden { display: none !important; }

    @keyframes steamRise {
        0% { transform: translateY(0); opacity: 0.1; }
        50%{ opacity: 0.35; }
        100%{ transform: translateY(-40px); opacity: 0; }
    }
    @keyframes bubblePulse {
        0% { transform: scale(0.8); opacity: 0.2; }
        50% { transform: scale(1.05); opacity: 0.6; }
        100% { transform: scale(0.8); opacity: 0.2; }
    }
    @keyframes knobTurn { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    @keyframes pourWater { 0%{ transform: translateY(0) scale(0.8);} 50%{ transform: translateY(-6px) scale(1);} 100%{ transform: translateY(0) scale(0.8);} }
    @keyframes sprinkleSeason { 0%{ transform: translateY(-10px); opacity: 0;} 100%{ transform: translateY(0); opacity: 1;} }
    @keyframes noodleSoften { 0%{ filter: saturate(0.5);} 100%{ filter: saturate(1.1);} }
    @keyframes successGlow { 0%,100%{ box-shadow: 0 0 0 0 rgba(16,185,129,0);} 50%{ box-shadow: 0 0 30px 10px rgba(16,185,129,0.35);} }
    @keyframes errorShake { 0%,100%{ transform: translateX(0);} 20%{ transform: translateX(-6px);} 40%{ transform: translateX(6px);} 60%{ transform: translateX(-4px);} 80%{ transform: translateX(4px);} }
    @keyframes cardSlideIn { from { transform: translateY(10px); opacity: 0; } to{ transform: translateY(0); opacity: 1; } }
    @keyframes tickFlash { from { opacity: 0.6; } to { opacity: 0.15; } }

    /* Responsive */
    @media (max-width: 1024px) {
        .grid { grid-template-columns: 1fr 1fr; grid-template-areas: "stage stage" "left right"; }
        #stage { grid-area: stage; }
    }
    @media (max-width: 768px) {
        body { padding-bottom: 120px; }
        .grid { grid-template-columns: 1fr; }
        #ingredients { grid-template-columns: repeat(2, 1fr); }
        #heatKnob { width: 100px; height: 100px; }
        #potArea { min-height: 320px; }
    }
</style>
</head>
<body>
    <div id="app">
        <div class="header">
            <div class="title">üçú Boilpoint: Night Market Ramen Lab <span class="badge">Beginner</span></div>
            <div class="pill" style="gap:10px">
                <span class="label">Learning Goal</span>
                <span class="value">Measure ¬±10%, simmer band, season timing, plate order</span>
            </div>
        </div>
        <p class="subtitle">You‚Äôre the closing chef at a neon night market. Match each ticket‚Äôs flavor and texture by mastering heat, timing, and visuals.</p>

        <div class="grid">
            <section id="hud" class="panel">
                <div class="statbar">
                    <div class="pill"><span class="label">Score</span><span class="value mono" id="scoreVal">000</span></div>
                    <div class="pill"><span class="label">Timer</span><span class="value mono" id="timerVal">00:00</span></div>
                    <div class="pill"><span class="label">Order Seed</span><span class="value mono" id="seedVal">-</span></div>
                </div>
                <div class="pill" style="margin-bottom:8px;">
                    <span class="label">Order Rail</span>
                    <span class="value">Unique ticket, randomized by seed</span>
                </div>
                <section id="orderCard" class="panel hoverLift">
                    <h3>Order Ticket</h3>
                    <div class="order-row">
                        <div class="order-item"><strong>Style</strong><span id="ocStyle">-</span></div>
                        <div class="order-item"><strong>Noodle</strong><span id="ocNoodle">-</span></div>
                    </div>
                    <div class="order-row">
                        <div class="order-item"><strong>Firmness</strong><span id="ocFirm">-</span></div>
                        <div class="order-item"><strong>Altitude</strong><span id="ocAlt">-</span></div>
                    </div>
                    <div class="order-row">
                        <div class="order-item"><strong>Pot Size</strong><span id="ocPot">-</span></div>
                        <div class="order-item"><strong>Water</strong><span id="ocWater">-</span></div>
                    </div>
                    <div class="order-row">
                        <div class="order-item"><strong>Cook Time</strong><span id="ocCook">-</span></div>
                        <div class="order-item"><strong>Add-ins Order</strong><span id="ocAddIns">-</span></div>
                    </div>
                    <div class="hint">Use visual cues: bubble intensity, steam, noodle coil looseness, broth turbidity.</div>
                    <div class="badge-list" id="badgeList"></div>
                </section>
            </section>

            <section id="stage" class="panel">
                <div class="stage-overlay">
                    <div class="overlay-pill mono">Water: <span id="hudWater">0</span> ml</div>
                    <div class="overlay-pill mono">Temp: <span id="hudTemp">20</span>¬∞C</div>
                    <div class="overlay-pill mono">Bubbles: <span id="hudBub">0</span></div>
                </div>
                <div id="potArea" aria-label="Pot Area for stirring and dropping" tabindex="0">
                    <div id="heatRing" class="ring-blue"></div>
                    <svg id="stageCanvas" viewBox="0 0 900 500" preserveAspectRatio="xMidYMid meet" aria-hidden="true">
                        <defs>
                            <filter id="steamBlur"><feGaussianBlur in="SourceGraphic" stdDeviation="2"/></filter>
                            <radialGradient id="brothGrad" cx="50%" cy="40%">
                                <stop offset="0%" stop-color="#bae6fd" stop-opacity="0.7"></stop>
                                <stop offset="100%" stop-color="#38bdf8" stop-opacity="0.8"></stop>
                            </radialGradient>
                            <radialGradient id="noodleGrad" cx="50%" cy="50%">
                                <stop offset="0%" stop-color="#fef3c7"></stop>
                                <stop offset="100%" stop-color="#f59e0b"></stop>
                            </radialGradient>
                            <linearGradient id="potMetal" x1="0" x2="0" y1="0" y2="1">
                                <stop offset="0%" stop-color="#94a3b8"/>
                                <stop offset="100%" stop-color="#1f2937"/>
                            </linearGradient>
                        </defs>
                        <g id="pot">
                            <ellipse cx="450" cy="380" rx="270" ry="26" fill="#111827" opacity="0.55"></ellipse>
                            <ellipse id="potLip" cx="450" cy="240" rx="260" ry="70" fill="url(#potMetal)" stroke="#475569" stroke-width="4"></ellipse>
                            <rect x="190" y="240" width="520" height="160" fill="url(#potMetal)" stroke="#475569" stroke-width="4" rx="12"></rect>
                            <ellipse id="potBase" cx="450" cy="400" rx="260" ry="50" fill="#0b1220"></ellipse>
                        </g>
                        <g id="waterGroup"></g>
                        <g id="noodleGroup"></g>
                        <g id="bubbleGroup"></g>
                        <g id="steamGroup" filter="url(#steamBlur)"></g>
                        <g id="pourParticles"></g>
                        <g id="seasonParticles"></g>
                    </svg>
                </div>
                <div class="legend">
                    Controls: Arrow Up/Down = Heat ¬±1, Space = Pause/Resume, S = Strain (if dry). Stir with circular mouse or touch gestures.
                </div>
            </section>

            <section id="rightCol" class="panel">
                <div id="controls">
                    <div class="group control-card">
                        <div class="knob-label">Heat Knob</div>
                        <div id="heatKnob" aria-label="Heat control" role="slider" aria-valuemin="0" aria-valuemax="10" aria-valuenow="0"></div>
                        <div class="pill"><span class="label">Level</span><span class="value mono" id="heatLevelVal">0</span></div>
                    </div>
                    <div class="group control-card">
                        <div class="knob-label">Water Pitcher</div>
                        <div id="waterPitcher">
                            <div class="icon hoverLift" id="pitcherIcon" title="Press and drag slider to pour"></div>
                            <input type="range" id="pourControl" min="0" max="100" value="0" />
                        </div>
                        <div class="pill"><span class="label">Target</span><span class="value mono" id="targetWater">-</span></div>
                    </div>
                    <div class="group control-card">
                        <div class="knob-label">Seasoning Packet</div>
                        <div id="seasonPacket" draggable="true" aria-label="Seasoning Packet">SEASON</div>
                        <div class="hint">Drag into pot at the right visual moment.</div>
                    </div>
                    <div class="group control-card">
                        <button id="strainerBtn" disabled>Strain</button>
                        <div class="hint" id="strainHint">Available for dry style when noodles are ready.</div>
                    </div>
                </div>

                <div class="group control-card">
                    <div class="knob-label">Add-ins</div>
                    <section id="ingredients">
                        <div class="ingredient" draggable="true" data-name="egg">
                            <div class="icon" style="background: radial-gradient(circle at 40% 40%, #fde68a, #f59e0b);"></div>
                            <div class="name">Egg</div>
                        </div>
                        <div class="ingredient" draggable="true" data-name="scallions">
                            <div class="icon" style="background: radial-gradient(circle at 40% 40%, #bbf7d0, #10b981);"></div>
                            <div class="name">Scallions</div>
                        </div>
                        <div class="ingredient" draggable="true" data-name="corn">
                            <div class="icon" style="background: radial-gradient(circle at 40% 40%, #fde68a, #facc15);"></div>
                            <div class="name">Corn</div>
                        </div>
                        <div class="ingredient" draggable="true" data-name="tofu">
                            <div class="icon" style="background: radial-gradient(circle at 40% 40%, #e5e7eb, #cbd5e1);"></div>
                            <div class="name">Tofu</div>
                        </div>
                    </section>
                    <div class="hint">Follow the order shown on the ticket.</div>
                </div>
            </section>
        </div>
    </div>

    <div id="timeline">
        <div class="timeline-inner">
            <div class="timeline-row">
                <div id="progress"><div id="progressBar"></div></div>
                <div class="timeline-controls">
                    <button id="pauseBtn" class="sm-btn">Pause</button>
                    <button id="submitBtn" class="sm-btn">Submit</button>
                </div>
                <div class="timeline-time" id="timeReadout">00:00 / 00:00</div>
            </div>
        </div>
    </div>

    <div id="toasts"></div>

    <div id="scoreModal" role="dialog" aria-modal="true" aria-labelledby="scoreTitle">
        <div class="modal-content">
            <div class="modal-header">
                <div>
                    <h2 id="scoreTitle">Round Summary</h2>
                    <div class="hint">Visual diff vs target states. Review and answer the challenge.</div>
                </div>
                <button class="sm-btn" id="closeModal">Close</button>
            </div>
            <div class="modal-body">
                <div>
                    <div class="score-bars" id="scoreBars">
                        <div class="bar">
                            <div class="label">Water (25)</div>
                            <div class="track"><div class="fill" id="barWater"></div></div>
                        </div>
                        <div class="bar">
                            <div class="label">Heat Control (20)</div>
                            <div class="track"><div class="fill" id="barHeat"></div></div>
                        </div>
                        <div class="bar">
                            <div class="label">Timing / Doneness (25)</div>
                            <div class="track"><div class="fill" id="barTiming"></div></div>
                        </div>
                        <div class="bar">
                            <div class="label">Seasoning (20)</div>
                            <div class="track"><div class="fill" id="barSeason"></div></div>
                        </div>
                        <div class="bar">
                            <div class="label">Plating (10)</div>
                            <div class="track"><div class="fill" id="barPlating"></div></div>
                        </div>
                        <div class="pill" style="margin-top:10px;">
                            <span class="label">Total</span>
                            <span class="value mono" id="totalScore">0</span>
                        </div>
                    </div>
                    <div class="replay" id="replay"></div>
                </div>
                <div>
                    <div class="challenge">
                        <strong>Challenge Question</strong>
                        <p style="margin-top:6px;">Based on your bowl‚Äôs visuals, identify the earliest correct moment to add seasoning for YOUR style and explain why earlier or later reduces quality. Provide timestamp (¬±3s), cues, and consequence.</p>
                        <textarea id="challengeInput" rows="6" placeholder="Example: 02:18. Cues: bubbles returned to steady medium band, noodle coils partially relaxed, broth still clear. Earlier -> muted flavor; later -> too salty."></textarea>
                        <button class="btn" style="margin-top:10px;" id="submitChallenge">Submit Answer</button>
                        <div class="hint" id="challengeFeedback"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
(function(){
    // Utility: Seeded RNG (mulberry32)
    function mulberry32(a){ return function() { var t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; } }
    function seedFrom(str){
        let h=1779033703^str.length;
        for(let i=0;i<str.length;i++){ h = Math.imul(h ^ str.charCodeAt(i), 3432918353); h = h<<13 | h>>>19; }
        return (h>>>0);
    }
    function randInt(rng, min, max){ return Math.floor(rng()*(max-min+1))+min; }
    function randChoice(rng, arr){ return arr[Math.floor(rng()*arr.length)]; }
    function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
    function formatTime(sec){ sec = Math.max(0, Math.floor(sec)); const m = Math.floor(sec/60); const s = sec%60; return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`; }

    // Audio feedback via WebAudio
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    function tone(freq=440, dur=0.08, type='sine', gain=0.06){
        try{
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.type = type; o.frequency.value = freq;
            g.gain.value = gain;
            o.connect(g).connect(audioCtx.destination);
            o.start();
            o.stop(audioCtx.currentTime + dur);
        }catch(e){}
    }
    function chimeSuccess(){ tone(880,0.07,'sine',0.04); setTimeout(()=>tone(1320,0.07,'sine',0.05),60); }
    function buzz(){ tone(140,0.12,'square',0.03); }

    // DOM refs
    const el = {
        seedVal: document.getElementById('seedVal'),
        scoreVal: document.getElementById('scoreVal'),
        timerVal: document.getElementById('timerVal'),
        ocStyle: document.getElementById('ocStyle'),
        ocNoodle: document.getElementById('ocNoodle'),
        ocFirm: document.getElementById('ocFirm'),
        ocAlt: document.getElementById('ocAlt'),
        ocPot: document.getElementById('ocPot'),
        ocWater: document.getElementById('ocWater'),
        ocCook: document.getElementById('ocCook'),
        ocAddIns: document.getElementById('ocAddIns'),
        targetWater: document.getElementById('targetWater'),
        badgeList: document.getElementById('badgeList'),
        stageCanvas: document.getElementById('stageCanvas'),
        bubbleGroup: document.getElementById('bubbleGroup'),
        waterGroup: document.getElementById('waterGroup'),
        noodleGroup: document.getElementById('noodleGroup'),
        steamGroup: document.getElementById('steamGroup'),
        pourParticles: document.getElementById('pourParticles'),
        seasonParticles: document.getElementById('seasonParticles'),
        heatKnob: document.getElementById('heatKnob'),
        heatRing: document.getElementById('heatRing'),
        heatLevelVal: document.getElementById('heatLevelVal'),
        pourControl: document.getElementById('pourControl'),
        pitcherIcon: document.getElementById('pitcherIcon'),
        seasonPacket: document.getElementById('seasonPacket'),
        strainerBtn: document.getElementById('strainerBtn'),
        strainHint: document.getElementById('strainHint'),
        potArea: document.getElementById('potArea'),
        hudWater: document.getElementById('hudWater'),
        hudTemp: document.getElementById('hudTemp'),
        hudBub: document.getElementById('hudBub'),
        progress: document.getElementById('progress'),
        progressBar: document.getElementById('progressBar'),
        pauseBtn: document.getElementById('pauseBtn'),
        submitBtn: document.getElementById('submitBtn'),
        timeReadout: document.getElementById('timeReadout'),
        scoreModal: document.getElementById('scoreModal'),
        barWater: document.getElementById('barWater'),
        barHeat: document.getElementById('barHeat'),
        barTiming: document.getElementById('barTiming'),
        barSeason: document.getElementById('barSeason'),
        barPlating: document.getElementById('barPlating'),
        totalScore: document.getElementById('totalScore'),
        replay: document.getElementById('replay'),
        closeModal: document.getElementById('closeModal'),
        challengeInput: document.getElementById('challengeInput'),
        submitChallenge: document.getElementById('submitChallenge'),
        challengeFeedback: document.getElementById('challengeFeedback'),
        toasts: document.getElementById('toasts'),
        ingredients: document.querySelectorAll('#ingredients .ingredient')
    };

    // Game State
    const nowSeed = Date.now().toString(36) + Math.random().toString(36).slice(2,7);
    const urlHash = (new URLSearchParams(location.search)).get('seed') || '';
    const studentId = (localStorage.getItem('studentId') || '').slice(0,16);
    const seedStr = (studentId || '') + (urlHash || '') || nowSeed;
    const rng = mulberry32(seedFrom(seedStr));
    const hueShift = Math.floor(rng()*60) - 30;

    const noodleThicknesses = ['thin','standard','thick'];
    const styles = ['soup','dry'];
    const firmnessLevels = ['springy','soft'];
    const addInPool = ['egg','scallions','corn','tofu','nori','chili'];

    const recipe = generateRecipe();
    const state = {
        seed: seedStr,
        studentId: studentId || 'anon',
        recipe,
        pot: { waterMl: 0, tempC: 22, heatLevel: randInt(rng, 1, 3), isBoiling: false, bubbleIntensity: 0 },
        noodle: { state:'dry', doneness0to1: 0, swirlCount: 0, swirled: false },
        seasoning: { addedAtSec: null, type: 'classic', isAdded: false },
        plating: { addedOrder: [] },
        actions: [],
        time: { elapsedSec: 0, running: true, lastTick: performance.now()/1000 },
        scoring: { waterScore: 0, heatScore: 0, timingScore: 0, seasoningScore: 0, platingScore: 0, total: 0 },
        ui: { locked: false, phase: 'boilup', hue: hueShift, jitter: {x:(rng()-0.5)*6,y:(rng()-0.5)*6} },
        windows: { simmer: {min: 0.45, max: 0.7}, targetDoneness: targetDoneness(recipe.targetFirmness) },
        flags: { noodlesDropped: true, boilResumedAt: null, strainedAt: null, completed: false }
    };

    // Jitter controls for anti-cheating feel
    document.getElementById('controls').style.transform = `translate(${state.ui.jitter.x}px, ${state.ui.jitter.y}px)`;
    document.getElementById('stage').style.filter = `hue-rotate(${state.ui.hue}deg)`;
    document.getElementById('rightCol').style.filter = `hue-rotate(${state.ui.hue/2}deg)`;

    // Initialize UI
    el.seedVal.textContent = state.seed.slice(0,10);
    renderOrderCard();
    el.targetWater.textContent = recipe.waterTargetMl + ' ml';
    el.timeReadout.textContent = `00:00 / ${formatTime(recipe.cookTimeSec)}`;

    // Stage initial draw
    drawWater();
    drawNoodles();
    drawBubbles(0);
    drawSteam(0);

    // Heat knob setup
    let knobAngle = state.pot.heatLevel * 27 - 135;
    setKnobRotation(knobAngle);
    el.heatLevelVal.textContent = state.pot.heatLevel.toFixed(0);

    // Drag & Drop handlers
    setupDragAndDrop();

    // Keyboard controls
    document.addEventListener('keydown', onKey);

    // Pour control
    el.pourControl.addEventListener('input', handlePour);
    el.pitcherIcon.addEventListener('click', ()=> {
        el.pourControl.value = Math.min(100, Number(el.pourControl.value)+10);
        handlePour();
        el.pitcherIcon.style.animation = 'pourWater 300ms ease';
        setTimeout(()=>el.pitcherIcon.style.animation='', 320);
    });

    // Strainer
    el.strainerBtn.addEventListener('click', toggleStrain);

    // Pause/Submit
    el.pauseBtn.addEventListener('click', togglePause);
    el.submitBtn.addEventListener('click', finishRound);
    el.closeModal.addEventListener('click', ()=> el.scoreModal.style.display='none');
    el.submitChallenge.addEventListener('click', validateChallenge);

    // Pot stir gesture detection
    setupStirDetection();

    // Render loop
    requestAnimationFrame(gameLoop);

    // Functions
    function generateRecipe(){
        const noodleThickness = randChoice(rng, noodleThicknesses);
        const style = randChoice(rng, styles);
        const altitude = randInt(rng, 0, 2000);
        const potSize = randChoice(rng, ['small','medium']);
        const baseWater = noodleThickness==='thin'? 350 : noodleThickness==='standard'? 450 : 550;
        const waterTargetMl = baseWater + (potSize==='medium'? 75 : 0) + randInt(rng, -20, 40);
        const cookTimeSec = noodleThickness==='thin'? randInt(rng, 150, 210) : noodleThickness==='standard'? randInt(rng, 210, 270) : randInt(rng, 270, 330);
        const addInsOrder = shuffle(rng, randSubset(rng, addInPool, randInt(rng, 3, 4)));
        return {
            style, noodleThickness, targetFirmness: randChoice(rng, firmnessLevels), altitude, potSize, waterTargetMl, cookTimeSec, addInsOrder
        };
    }
    function targetDoneness(firm){ return firm==='springy' ? 0.6 : 0.82; }

    function shuffle(rng, arr){ const a = [...arr]; for(let i=a.length-1;i>0;i--){ const j = Math.floor(rng()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
    function randSubset(rng, arr, count){ const a = shuffle(rng, arr); return a.slice(0,count); }

    function renderOrderCard(){
        el.ocStyle.textContent = recipe.style.toUpperCase();
        el.ocNoodle.textContent = `${recipe.noodleThickness}`;
        el.ocFirm.textContent = recipe.targetFirmness;
        el.ocAlt.textContent = `${recipe.altitude} m`;
        el.ocPot.textContent = recipe.potSize;
        el.ocWater.textContent = `${recipe.waterTargetMl} ml`;
        el.ocCook.textContent = `${Math.round(recipe.cookTimeSec/60)} min ${recipe.cookTimeSec%60}s`;
        el.ocAddIns.textContent = recipe.addInsOrder.join(' ‚Üí ');
        el.badgeList.innerHTML = '';
        ['Simmer band', '¬±10% water', 'Stir early', recipe.style === 'dry' ? 'Strain window' : 'Boil return', 'Add-in order'].forEach(t=>{
            const b = document.createElement('div'); b.className='badge-item'; b.textContent = t; el.badgeList.appendChild(b);
        });
    }

    function setKnobRotation(angle){
        el.heatKnob.style.transform = `rotate(${angle}deg)`;
        el.heatKnob.setAttribute('aria-valuenow', state.pot.heatLevel.toFixed(0));
    }

    // Heat knob pointer rotation
    (function(){
        let dragging=false, origin={x:0,y:0};
        el.heatKnob.addEventListener('pointerdown', e=>{
            dragging=true; origin = el.heatKnob.getBoundingClientRect();
            el.heatKnob.setPointerCapture(e.pointerId);
        });
        window.addEventListener('pointermove', e=>{
            if(!dragging) return;
            const cx = origin.left + origin.width/2;
            const cy = origin.top + origin.height/2;
            const dx = e.clientX - cx;
            const dy = e.clientY - cy;
            let ang = Math.atan2(dy, dx) * 180/Math.PI + 90;
            if(ang < -135) ang = -135;
            if(ang > 135) ang = 135;
            knobAngle = ang;
            const level = Math.round(((ang + 135)/270)*10);
            setHeat(level);
        });
        window.addEventListener('pointerup', e=> { dragging=false; });
    })();

    function setHeat(level){
        const clamped = clamp(level, 0, 10);
        if (state.pot.heatLevel !== clamped) {
            state.pot.heatLevel = clamped;
            el.heatLevelVal.textContent = clamped.toString();
            state.actions.push({t:state.time.elapsedSec, type:'heat', level:clamped});
            knobAngle = clamped * 27 - 135;
            setKnobRotation(knobAngle);
            tone(300 + clamped*30, 0.04, 'sine', 0.02);
        }
    }

    function boilingPointC(alt){ return 100 - (alt/285); }

    function updatePhysics(dt){
        const boilPoint = boilingPointC(state.recipe.altitude);
        const massFactor = 1 + (state.pot.waterMl/600);
        const ambient = 22;
        const heatInput = state.pot.heatLevel * 2.0; // power
        const loss = (state.pot.tempC - ambient) * 0.06;
        let dT = (heatInput - loss) / massFactor;
        state.pot.tempC += dT * dt;
        if (state.pot.tempC > boilPoint) {
            state.pot.tempC -= (state.pot.tempC - boilPoint) * 0.15; // clamp near boiling
        }
        state.pot.isBoiling = state.pot.tempC >= (boilPoint - 0.8);

        // bubble intensity mapping: depends on heat and proximity to boil
        const near = clamp((state.pot.tempC - (boilPoint - 10))/10, 0, 1);
        const heatFactor = state.pot.heatLevel/10;
        state.pot.bubbleIntensity = clamp(near * (0.2 + 0.8*heatFactor), 0, 1);

        // simmer band feedback
        const bi = state.pot.bubbleIntensity;
        const ring = el.heatRing.classList;
        ring.remove('ring-green','ring-yellow','ring-red','ring-blue');
        let ringClass = 'ring-blue';
        if (bi < state.windows.simmer.min*0.8) ringClass='ring-blue';
        else if (bi >= state.windows.simmer.min && bi <= state.windows.simmer.max) ringClass = 'ring-green';
        else if (bi > state.windows.simmer.max && bi < 0.9) ringClass = 'ring-yellow';
        else ringClass = 'ring-red';
        ring.add(ringClass);

        if (state.pot.bubbleIntensity > 0.92 && state.pot.waterMl > state.recipe.waterTargetMl*1.15) {
            // boil over risk feedback
            el.potArea.style.animation = 'errorShake 450ms ease';
            setTimeout(()=> el.potArea.style.animation='', 460);
            buzz();
        }

        // noodle cooking progression (auto noodles already in)
        const cooking = state.pot.waterMl > 10 && state.pot.tempC > 70;
        if (cooking) {
            const baseRate = 0.035; // per second towards 1.0
            const tempFactor = clamp((state.pot.tempC-70)/30, 0, 1);
            const stirFactor = state.noodle.swirled ? 1.08 : 0.98;
            const thicknessFactor = state.recipe.noodleThickness==='thin'? 1.15 : state.recipe.noodleThickness==='standard' ? 1 : 0.85;
            state.noodle.doneness0to1 += baseRate * tempFactor * stirFactor * thicknessFactor * dt;
            if (state.noodle.doneness0to1 > 1.25) state.noodle.doneness0to1 = 1.25;
            if (state.noodle.doneness0to1 >= state.windows.targetDoneness && !state.flags.donenessChime) {
                chimeSuccess(); state.flags.donenessChime = true;
            }
        }

        updateSeasoningWindows(boilPoint);
        updateUI();
        drawStage();
    }

    function updateSeasoningWindows(boilPoint){
        // detect boil returned after drop (since noodles auto dropped at start)
        if (state.pot.isBoiling && state.flags.boilResumedAt === null && state.time.elapsedSec > 3) {
            state.flags.boilResumedAt = state.time.elapsedSec;
        }
        // enable strainer when dry and in window
        const windowMin = state.windows.targetDoneness - 0.06;
        const windowMax = state.windows.targetDoneness + 0.06;
        const inWindow = state.noodle.doneness0to1 >= windowMin && state.noodle.doneness0to1 <= windowMax;
        if (state.recipe.style === 'dry') {
            el.strainerBtn.disabled = !(inWindow && state.pot.waterMl > 40 && !state.flags.strainedAt);
            el.strainHint.textContent = el.strainerBtn.disabled ? 'Strain when doneness window is green.' : 'Strain now!';
            if (!state.flags.strainHintShown && inWindow) { toast('Strain is available now.'); state.flags.strainHintShown = true; }
        } else {
            el.strainerBtn.disabled = true;
            el.strainHint.textContent = 'Soup style: straining disabled.';
        }
    }

    function updateUI(){
        el.hudWater.textContent = Math.round(state.pot.waterMl);
        el.hudTemp.textContent = Math.round(state.pot.tempC);
        el.hudBub.textContent = state.pot.bubbleIntensity.toFixed(2);
        el.timerVal.textContent = formatTime(state.time.elapsedSec);
        el.timeReadout.textContent = `${formatTime(state.time.elapsedSec)} / ${formatTime(state.recipe.cookTimeSec)}`;
        // progress
        const p = clamp(state.time.elapsedSec / state.recipe.cookTimeSec, 0, 1) * 100;
        el.progressBar.style.width = `${p}%`;
    }

    function drawStage(){
        drawWater();
        drawNoodles();
        drawBubbles(state.pot.bubbleIntensity);
        drawSteam(state.pot.heatLevel/10);
    }

    function drawWater(){
        const g = el.waterGroup; g.innerHTML = '';
        const maxDepth = 120; // px
        const depth = clamp(state.pot.waterMl / 700, 0, 1) * maxDepth;
        // broth color shifts after seasoning
        const baseHue = 195 + state.ui.hue*0.1;
        const brothColor = state.seasoning.isAdded ? `hsla(${baseHue-30}, 85%, 60%, ${0.92})` : `hsla(${baseHue}, 85%, 70%, ${0.82})`;
        const turbidity = state.seasoning.isAdded ? 0.25 + clamp((state.time.elapsedSec - (state.seasoning.addedAtSec||0))/30,0,0.35) : 0.08;
        const opacity = clamp(0.35 + turbidity, 0.35, 0.9);
        const y = 240 + (120 - depth);
        const rx = 240, ry = 60;
        g.appendChild(svgEl('ellipse', { cx: 450, cy: y, rx: rx, ry: ry, fill: brothColor, opacity: 0.95 }));
        g.appendChild(svgEl('rect', { x: 210, y: y, width: 480, height: Math.max(0, 240 + depth - y), fill: brothColor, opacity }));
        g.appendChild(svgEl('ellipse', { cx: 450, cy: 240 + depth, rx: rx, ry: ry, fill: brothColor, opacity }));
    }

    function drawNoodles(){
        const g = el.noodleGroup; g.innerHTML = '';
        const d = clamp(state.noodle.doneness0to1, 0, 1.25);
        // coil looseness: more doneness -> larger radius and warmer color
        const loops = 6;
        const baseR = 40 + d*30;
        const color = d < 0.6 ? '#fde68a' : d < 0.9 ? '#f59e0b' : '#d97706';
        for (let i=0; i<loops; i++){
            const r = baseR + i*7;
            g.appendChild(svgEl('ellipse', { cx: 450, cy: 300, rx:  r*2.5, ry: r, fill: 'none', stroke: color, 'stroke-width': 2, opacity: 0.75 }));
        }
        if (d>0.05) el.noodleGroup.style.animation = 'noodleSoften 900ms ease';
    }

    function drawBubbles(intensity){
        const g = el.bubbleGroup; g.innerHTML = '';
        const count = Math.floor(10 + intensity*80);
        for (let i=0;i<count;i++){
            const x = 240 + Math.random()*420;
            const y = 260 + Math.random()*140;
            const r = 2 + Math.random()*6*intensity;
            const c = svgEl('circle', { cx: x, cy: y, r, fill: 'rgba(255,255,255,0.6)' });
            c.style.animation = `bubblePulse ${1200 + Math.random()*1200}ms ease-in-out infinite`;
            g.appendChild(c);
        }
    }

    function drawSteam(level){
        const g = el.steamGroup; g.innerHTML = '';
        const layers = Math.floor(level*4);
        for (let i=0;i<layers;i++){
            for (let j=0;j<8;j++){
                const x = 350 + Math.random()*200;
                const y = 200 + Math.random()*40;
                const r = 6 + Math.random()*20;
                const o = svgEl('circle', { cx: x, cy: y, r, fill: 'rgba(226, 245, 255, 0.25)' });
                o.style.animation = `steamRise ${1500 + Math.random()*1500}ms linear ${Math.random()*0.6}s infinite`;
                g.appendChild(o);
            }
        }
    }

    function svgEl(tag, attrs){
        const e = document.createElementNS('http://www.w3.org/2000/svg', tag);
        for (const k in attrs) e.setAttribute(k, attrs[k]);
        return e;
    }

    function handlePour(){
        // convert slider delta to ml pour relative to target
        const percent = Number(el.pourControl.value);
        const target = state.recipe.waterTargetMl;
        const ml = Math.round((percent/100) * target * 1.3); // allow overfill to 130% target
        const delta = ml - state.pot.waterMl;
        if (Math.abs(delta) > 0){
            state.pot.waterMl = clamp(ml, 0, target*1.6);
            state.actions.push({t:state.time.elapsedSec, type:'pour', ml: state.pot.waterMl});
            // particles
            spawnPourParticles(Math.sign(delta));
            tone(440 + (state.pot.waterMl/target)*60, 0.04, 'triangle', 0.02);
        }
        validateWaterTarget();
    }

    function spawnPourParticles(dir=1){
        const g = el.pourParticles;
        for (let i=0;i<6;i++){
            const p = svgEl('circle',{ cx: 620 + Math.random()*20, cy: 230 + Math.random()*10, r: 2+Math.random()*3, fill:'#a5f3fc' });
            p.style.animation = `sprinkleSeason 300ms ease`;
            g.appendChild(p);
            setTimeout(()=> p.remove(), 320);
        }
    }

    function validateWaterTarget(){
        const target = state.recipe.waterTargetMl;
        const dev = Math.abs(state.pot.waterMl - target)/target;
        if (dev <= 0.1) {
            toast('Water is within ¬±10% target.', 'success');
        }
    }

    function setupDragAndDrop(){
        // Seasoning
        el.seasonPacket.addEventListener('dragstart', e=>{
            e.dataTransfer.setData('text/plain', 'season');
            el.seasonPacket.style.opacity = '0.7';
        });
        el.seasonPacket.addEventListener('dragend', () => el.seasonPacket.style.opacity = '1');

        // Ingredients
        el.ingredients.forEach(item=>{
            item.addEventListener('dragstart', e=>{
                e.dataTransfer.setData('text/plain', 'ing:'+item.dataset.name);
                item.style.opacity='0.7';
            });
            item.addEventListener('dragend', e=> item.style.opacity='1');
        });

        // Pot drop zone
        ['dragover','dragenter'].forEach(evt=>{
            el.potArea.addEventListener(evt, e=> { e.preventDefault(); });
        });
        el.potArea.addEventListener('drop', e=>{
            e.preventDefault();
            const data = e.dataTransfer.getData('text/plain') || '';
            if (!data) return;
            if (data === 'season') {
                handleSeasoningDrop();
            } else if (data.startsWith('ing:')) {
                const ing = data.split(':')[1];
                handleDropIngredient(ing);
            }
        });
    }

    function handleSeasoningDrop(){
        if (state.seasoning.isAdded) { toast('Seasoning already added.', 'warn'); buzz(); return; }
        if (state.recipe.style === 'soup') {
            if (!state.flags.boilResumedAt || state.time.elapsedSec < state.flags.boilResumedAt) {
                toast('Wait until boil returns to a steady simmer for soup style.', 'warn'); buzz(); return;
            }
            // allow up to 30% over target doneness
            if (state.noodle.doneness0to1 > state.windows.targetDoneness * 1.3) {
                toast('Too late for seasoning (soup).', 'error'); buzz(); return;
            }
        } else {
            // dry: only after strain and within 10s
            if (!state.flags.strainedAt) { toast('Strain first for dry style.', 'warn'); buzz(); return; }
            if (state.time.elapsedSec - state.flags.strainedAt > 10) { toast('Seasoning added too late after straining (dry).', 'error'); buzz(); return; }
            if (state.pot.waterMl < 20) { toast('Need residual water to coat (dry).', 'warn'); buzz(); return; }
        }
        // Add seasoning
        state.seasoning.isAdded = true;
        state.seasoning.addedAtSec = state.time.elapsedSec;
        state.actions.push({t:state.time.elapsedSec, type:'season'});
        sprinkle();
        chimeSuccess();
        toast('Seasoning added!', 'success');
    }

    function sprinkle(){
        const g = el.seasonParticles; g.innerHTML='';
        for(let i=0;i<30;i++){
            const x = 450 + (Math.random()-0.5)*180;
            const y = 250 + Math.random()*80;
            const p = svgEl('circle', { cx:x, cy:y, r: 1+Math.random()*3, fill:'#f59e0b' });
            p.style.animation = `sprinkleSeason 400ms ease`;
            g.appendChild(p);
            setTimeout(()=> p.remove(), 420 + Math.random()*200);
        }
    }

    function handleDropIngredient(name){
        // Validation and order
        const next = recipe.addInsOrder[state.plating.addedOrder.length];
        if (name !== next) {
            toast(`Incorrect order. Expected ${next}.`, 'error'); buzz();
            el.potArea.style.animation = 'errorShake 450ms ease';
            setTimeout(()=> el.potArea.style.animation='', 460);
            state.actions.push({t:state.time.elapsedSec, type:'add-in-wrong', name});
            return;
        }
        // Check doneness window for best points
        const windowMin = state.windows.targetDoneness - 0.06;
        const windowMax = state.windows.targetDoneness + 0.06;
        const inWindow = state.noodle.doneness0to1 >= windowMin && state.noodle.doneness0to1 <= windowMax;
        state.plating.addedOrder.push(name);
        state.actions.push({t:state.time.elapsedSec, type:'add-in', name});
        toast(`Added ${name}${inWindow?' (perfect timing)':''}.`, inWindow?'success':'info');
        chimeSuccess();
    }

    function toggleStrain(){
        if (state.recipe.style !== 'dry') return;
        const windowMin = state.windows.targetDoneness - 0.06;
        const windowMax = state.windows.targetDoneness + 0.06;
        const inWindow = state.noodle.doneness0to1 >= windowMin && state.noodle.doneness0to1 <= windowMax;
        if (!inWindow) { toast('Strained at wrong time (affects texture).', 'warn'); buzz(); }
        if (state.flags.strainedAt) { toast('Already strained.', 'warn'); return; }
        // animate drain
        const startWater = state.pot.waterMl;
        const residual = 35 + Math.random()*15;
        const start = performance.now();
        const dur = 900;
        state.flags.strainedAt = state.time.elapsedSec;
        state.actions.push({t:state.time.elapsedSec, type:'strain'});
        function drainStep(ts){
            const p = clamp((ts - start)/dur, 0, 1);
            state.pot.waterMl = startWater - (startWater - residual)*p;
            drawWater();
            if (p<1) requestAnimationFrame(drainStep);
        }
        requestAnimationFrame(drainStep);
        chimeSuccess();
        el.strainerBtn.disabled = true;
        el.strainHint.textContent = 'Strained';
    }

    function setupStirDetection(){
        let tracking = false;
        let lastAngle = null;
        let turns = 0;
        const center = () => {
            const rect = el.potArea.getBoundingClientRect();
            return { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
        };
        function angleAt(e){
            const c = center();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - c.x;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - c.y;
            return Math.atan2(y, x);
        }
        function start(e){ tracking = true; lastAngle = angleAt(e); turns = 0; state.actions.push({t:state.time.elapsedSec, type:'stir-start'}); }
        function move(e){
            if(!tracking) return;
            const a = angleAt(e);
            let delta = a - lastAngle;
            // normalize
            if (delta > Math.PI) delta -= 2*Math.PI;
            if (delta < -Math.PI) delta += 2*Math.PI;
            if (delta > 0.15) { turns += delta; lastAngle = a; }
            if (Math.abs(delta) > 0.01) {
                // swirl visual
                state.noodle.swirled = true;
            }
            if (turns > 2*Math.PI) {
                state.noodle.swirlCount++;
                turns = 0;
                state.actions.push({t:state.time.elapsedSec, type:'stir-turn', count: state.noodle.swirlCount});
                toast(`Swirl ${state.noodle.swirlCount}`, 'info');
                chimeSuccess();
            }
        }
        function end(){ tracking=false; lastAngle=null; state.noodle.swirled = false; state.actions.push({t:state.time.elapsedSec, type:'stir-end'}); }
        el.potArea.addEventListener('mousedown', start);
        el.potArea.addEventListener('mousemove', move);
        window.addEventListener('mouseup', end);
        el.potArea.addEventListener('touchstart', start, {passive:true});
        el.potArea.addEventListener('touchmove', move, {passive:true});
        el.potArea.addEventListener('touchend', end);
    }

    function togglePause(){
        state.time.running = !state.time.running;
        el.pauseBtn.textContent = state.time.running ? 'Pause' : 'Resume';
        state.actions.push({t:state.time.elapsedSec, type: state.time.running ? 'resume':'pause'});
    }

    function onKey(e){
        if (e.repeat) return;
        if (e.key === 'ArrowUp') { setHeat(state.pot.heatLevel+1); }
        if (e.key === 'ArrowDown') { setHeat(state.pot.heatLevel-1); }
        if (e.code === 'Space') { e.preventDefault(); togglePause(); }
        if (e.key.toLowerCase() === 's') { toggleStrain(); }
    }

    function gameLoop(ts){
        const t = ts/1000;
        const dt = Math.min(0.1, t - state.time.lastTick);
        state.time.lastTick = t;
        if (state.time.running) {
            state.time.elapsedSec += dt;
            // each second tick flash
            if (Math.floor(state.time.elapsedSec) !== Math.floor(state.time.elapsedSec - dt)) {
                secondTick();
            }
            updatePhysics(dt);
        }
        requestAnimationFrame(gameLoop);
    }

    function secondTick(){
        const tick = document.createElement('div');
        tick.className = 'tick';
        const pct = clamp(state.time.elapsedSec/state.recipe.cookTimeSec,0,1)*100;
        tick.style.left = `calc(${pct}% - 1px)`;
        el.progress.appendChild(tick);
        setTimeout(()=> tick.remove(), 900);
        tone(880, 0.01, 'sine', 0.01);
    }

    function toast(msg, type='info'){
        const t = document.createElement('div');
        t.className = 'toast';
        t.textContent = msg;
        if (type==='success') t.style.borderColor = 'rgba(16,185,129,0.6)';
        if (type==='error') t.style.borderColor = 'rgba(239,68,68,0.6)';
        if (type==='warn') t.style.borderColor = 'rgba(245,158,11,0.6)';
        el.toasts.appendChild(t);
        setTimeout(()=> { t.style.opacity='0'; t.style.transform='translateY(-6px)'; }, 2500);
        setTimeout(()=> t.remove(), 3000);
    }

    function finishRound(){
        if (state.flags.completed) return;
        state.flags.completed = true;
        state.time.running = false;

        // Scoring
        const target = state.recipe.waterTargetMl;
        const waterDev = Math.abs(state.pot.waterMl - target)/target;
        const waterScore = Math.max(0, 25 * (1 - Math.min(waterDev/0.4, 1))); // full if 0 dev, 0 if 40% off

        // Heat score: time in simmer band (approx by bubble intensity history -> here we approximate using current)
        // We'll approximate: better if final few seconds in band
        const bi = state.pot.bubbleIntensity;
        const inBand = (bi >= state.windows.simmer.min && bi <= state.windows.simmer.max);
        const heatScore = Math.round(20 * (inBand ? 0.9 : 0.45));

        // Timing score: doneness relative to target at finish
        const d = state.noodle.doneness0to1;
        const td = state.windows.targetDoneness;
        const dErr = Math.abs(d - td) / 0.35; // 0.35 tolerance to zero
        const timingScore = Math.max(0, 25 * (1 - Math.min(dErr, 1)));

        // Seasoning score: window conditions
        let seasoningScore = 0;
        if (state.seasoning.isAdded) {
            if (state.recipe.style === 'soup') {
                const ok1 = state.flags.boilResumedAt && state.seasoning.addedAtSec >= state.flags.boilResumedAt;
                const ok2 = d <= td*1.3;
                seasoningScore = (ok1 && ok2) ? 18 + (inBand?2:0) : (ok1 || ok2) ? 12 : 6;
            } else {
                const ok1 = state.flags.strainedAt && (state.seasoning.addedAtSec - state.flags.strainedAt) <= 10 && state.pot.waterMl >= 20;
                seasoningScore = ok1 ? 20 : 10;
            }
        } else {
            seasoningScore = 2;
        }

        // Plating score: correct add-ins in order
        let correct = 0;
        for (let i=0;i<state.plating.addedOrder.length;i++){
            if (state.plating.addedOrder[i] === state.recipe.addInsOrder[i]) correct++;
        }
        const platingScore = Math.round(10 * (correct / state.recipe.addInsOrder.length));

        const total = Math.round(waterScore + heatScore + timingScore + seasoningScore + platingScore);
        state.scoring = { waterScore, heatScore, timingScore, seasoningScore, platingScore, total };
        el.scoreVal.textContent = String(total).padStart(3,'0');

        openScoreModal();
    }

    function openScoreModal(){
        el.barWater.style.width = `${(state.scoring.waterScore/25)*100}%`;
        el.barHeat.style.width = `${(state.scoring.heatScore/20)*100}%`;
        el.barTiming.style.width = `${(state.scoring.timingScore/25)*100}%`;
        el.barSeason.style.width = `${(state.scoring.seasoningScore/20)*100}%`;
        el.barPlating.style.width = `${(state.scoring.platingScore/10)*100}%`;
        el.totalScore.textContent = state.scoring.total;
        // replay
        el.replay.innerHTML = '';
        state.actions.forEach(a=>{
            const div = document.createElement('div');
            div.className = 'replay-item';
            div.textContent = `[${formatTime(a.t)}] ${a.type} ${a.level!==undefined?('‚Üí'+a.level): a.ml!==undefined?('‚Üí'+Math.round(a.ml)+'ml'): a.name?('('+a.name+')'):''}`;
            el.replay.appendChild(div);
        });
        el.scoreModal.style.display = 'flex';
        el.scoreModal.querySelector('.modal-content').style.animation = 'successGlow 1200ms ease';
    }

    function validateChallenge(){
        const answer = el.challengeInput.value.trim();
        if (!answer) { toast('Please enter your reasoning.', 'warn'); return; }
        // Extract timestamp pattern mm:ss
        const match = answer.match(/(\d{1,2}):(\d{2})/);
        let ts = null;
        if (match) {
            ts = parseInt(match[1],10)*60 + parseInt(match[2],10);
        }
        const cues = ['bubble','simmer','coil','noodle','broth','clarity','opacity','steam'].filter(k => answer.toLowerCase().includes(k));
        const consequence = (state.recipe.style==='soup' ? (answer.toLowerCase().includes('salty') || answer.toLowerCase().includes('muted')) : (answer.toLowerCase().includes('clump') || answer.toLowerCase().includes('coat')));
        const result = gradeChallenge(ts, cues.length, consequence);
        el.challengeFeedback.textContent = result.message;
        toast(result.toast, result.ok?'success': result.partial?'info':'error');
    }

    function gradeChallenge(ts, cuesCount, consequenceOK){
        const style = state.recipe.style;
        let okTs = false, partialTs = false;
        if (ts !== null) {
            if (style === 'soup') {
                const minTs = state.flags.boilResumedAt || 0;
                const maxTs = state.time.elapsedSecAtSubmit || (state.time.elapsedSec);
                const latest = Math.floor(state.recipe.cookTimeSec * 1.3); // fallback if missing
                const d = state.noodle.doneness0to1;
                const upper = Math.floor(state.time.elapsedSec * (state.windows.targetDoneness*1.3 / (d || (state.windows.targetDoneness*1.3))));
                okTs = ts >= minTs && ts <= upper;
                partialTs = ts >= (minTs-6) && ts <= (upper+6);
            } else {
                const minTs = (state.flags.strainedAt || 0);
                okTs = ts !== null && (ts >= minTs) && (ts <= minTs + 10);
                partialTs = ts !== null && (ts >= minTs-6) && (ts <= minTs + 16);
            }
        }
        let okCues = cuesCount >= 2;
        let partialCues = cuesCount >= 1;
        const ok = okTs && okCues && consequenceOK;
        const partial = (partialTs && (okCues || partialCues) && consequenceOK) || (okTs && partialCues && consequenceOK);
        let message = '';
        let toastMsg = '';
        if (ok) {
            message = "Perfect timing and reasoning‚Äîyour visual read of simmer and coil softness was spot on!";
            toastMsg = 'Challenge: Full credit!';
        } else if (partial) {
            message = "Close! Your timing was nearly correct; mention both bubble intensity and noodle coil state for full credit.";
            toastMsg = 'Challenge: Partial credit';
        } else if (!okTs) {
            message = "Not quite‚Äîyour timestamp missed the seasoning window. Rewatch the replay and look for simmer returning before seasoning.";
            toastMsg = 'Challenge: Incorrect timestamp';
        } else {
            message = "Good reasoning about consequences, but you missed a key visual cue. Identify both bubble level and broth change.";
            toastMsg = 'Challenge: Needs better cues';
        }
        return { ok, partial, message, toast: toastMsg };
    }

    // Update recorded elapsed at submit for challenge grading window
    Object.defineProperty(state.time, 'elapsedSecAtSubmit', {
        get(){ return state._submitTime; },
        set(v){ state._submitTime = v; }
    });

    // Anti-cheating: checksum of action log
    function logChecksum(){
        const str = JSON.stringify(state.actions);
        let hash = 0;
        for(let i=0;i<str.length;i++){ hash = ((hash<<5)-hash) + str.charCodeAt(i); hash |= 0; }
        return (hash>>>0).toString(16);
    }

    // Helpers
    function finishIfAuto(){
        // auto-submit if all add-ins placed and seasoning added appropriately (demo convenience)
    }

    // End-of-round hook
    function finishRoundHook(){
        state.time.elapsedSecAtSubmit = state.time.elapsedSec;
        state.actions.push({t:state.time.elapsedSec, type:'submit', checksum: logChecksum()});
    }

    // Wrap finishRound to include hook
    const _finishRound = finishRound;
    finishRound = function(){
        finishRoundHook();
        _finishRound();
    }

    // Visual tick in progress bar at T-10s to target
    setInterval(()=>{
        const rem = state.recipe.cookTimeSec - state.time.elapsedSec;
        if (rem <= 10 && rem > 9.6) { toast('10s to target cook time‚Äîcheck noodle coils and bubble band.'); }
    }, 500);

    // drag stir on mobile: ensure pot area focusable
    el.potArea.addEventListener('focus', ()=> {});

    // Initial instructions
    setTimeout(()=>{
        toast('Pour water to target ¬±10%');
        toast('Dial heat to reach a steady simmer (green ring).');
        toast('Stir in circles early to prevent clumping.');
    }, 500);

    // ==== End of main IIFE ====

    // Local functions used above but hoisted for readability
    function finishRound(){ /* replaced above */ }

})();
</script>
</body>
</html>